{"name":"Mathlib.Tactic.Linarith.Parsing","instances":[{"typeNames":["Std.TreeMap"],"name":"Std.TreeMap.instBEq_mathlib","className":"BEq"},{"typeNames":["Mathlib.Tactic.Linarith.Monom"],"name":"Mathlib.Tactic.Linarith.instOrdMonom","className":"Ord"}],"imports":["Init","Mathlib.Tactic.Linarith.Datatypes"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L256-L268","name":"Mathlib.Tactic.Linarith.linearFormsAndMaxVar","line":256,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.linearFormsAndMaxVar","doc":"`linearFormsAndMaxVar red pfs` is the main interface for computing the linear forms of a list\nof expressions. Given a list `pfs` of proofs of comparisons, it produces a list `c` of `Comp`s of\nthe same length, such that `c[i]` represents the linear form of the type of `pfs[i]`.\n\nIt also returns the largest variable index that appears in comparisons in `c`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.linearFormsAndMaxVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">linearFormsAndMaxVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pfs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L244-L254","name":"Mathlib.Tactic.Linarith.toCompFold","line":244,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.toCompFold","doc":"`toCompFold red e_map exprs monom_map` folds `toComp` over `exprs`,\nupdating `e_map` and `monom_map` as it goes.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.toCompFold\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">toCompFold</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L229-L242","name":"Mathlib.Tactic.Linarith.toComp","line":229,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.toComp","doc":"`toComp red e e_map monom_map` converts an expression of the form `t < 0`, `t ≤ 0`, or `t = 0`\ninto a `comp` object.\n\n`e_map` maps atomic expressions to indices; `monom_map` maps monomials to indices.\nBoth of these are updated during processing and returned.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.toComp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">toComp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e_map</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">monom_map</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L212-L227","name":"Mathlib.Tactic.Linarith.elimMonom","line":212,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.elimMonom","doc":"`elimMonom s map` eliminates the monomial level of the `Sum` `s`.\n\n`map` is a lookup map from monomials to variable numbers.\nThe output `TreeMap ℕ ℤ` has the same structure as `s : Sum`,\nbut each monomial key is replaced with its index according to `map`.\nIf any new monomials are encountered, they are assigned variable numbers and `map` is updated.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.elimMonom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">elimMonom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\">Map</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L170-L210","name":"Mathlib.Tactic.Linarith.linearFormOfExpr","line":170,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.linearFormOfExpr","doc":"`linearFormOfExpr red map e` computes the linear form of `e`.\n\n`map` is a lookup map from atomic expressions to variable numbers.\nIf a new atomic expression is encountered, it is added to the map with a new number.\nIt matches atomic expressions up to reducibility given by `red`.\n\nBecause it matches up to definitional equality, this function must be in the `MetaM` monad,\nand forces some functions that call it into `MetaM` as well.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.linearFormOfExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">linearFormOfExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L157-L168","name":"Mathlib.Tactic.Linarith.linearFormOfAtom","line":157,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.linearFormOfAtom","doc":"`linearFormOfAtom red map e` is the atomic case for `linear_form_of_expr`.\nIf `e` appears with index `k` in `map`, it returns the singleton sum `var k`.\nOtherwise it updates `map`, adding `e` with index `n`, and returns the singleton sum `var n`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.linearFormOfAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">linearFormOfAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\">ExprMap</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L149-L155","name":"Mathlib.Tactic.Linarith.ExprMap","line":149,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap","doc":"`ExprMap` is used to record atomic expressions which have been seen while processing inequality\nexpressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.ExprMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">ExprMap</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L140-L142","name":"Mathlib.Tactic.Linarith.var","line":140,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.var","doc":"A single variable `n` is represented by a sum with coefficient `1` and monomial `n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.var\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">var</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L136-L138","name":"Mathlib.Tactic.Linarith.scalar","line":136,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.scalar","doc":"A scalar `z` is represented by a `Sum` with coefficient `z` and monomial `one` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.scalar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">scalar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">z</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L133-L134","name":"Mathlib.Tactic.Linarith.one","line":133,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.one","doc":"The unit monomial `one` is represented by the empty TreeMap. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L129-L131","name":"Mathlib.Tactic.Linarith.SumOfMonom","line":129,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.SumOfMonom","doc":"`SumOfMonom m` lifts `m` to a sum with coefficient `1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.SumOfMonom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">SumOfMonom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L117-L127","name":"Mathlib.Tactic.Linarith.Sum.pow","line":117,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.pow","doc":"The `n`th power of `s : Sum` is the `n`-fold product of `s`, with `s.pow 0 = Sum.one`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Sum</span>.<span class=\"name\">pow</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L112-L115","name":"Mathlib.Tactic.Linarith.Sum.mul","line":112,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.mul","doc":"`sum.mul s1 s2` distributes the multiplication of two sums. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Sum</span>.<span class=\"name\">mul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s1 </span><span class=\"fn\">s2</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L108-L110","name":"Mathlib.Tactic.Linarith.Sum.scaleByMonom","line":108,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.scaleByMonom","doc":"`Sum.scaleByMonom s m` multiplies every monomial in `s` by `m`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.scaleByMonom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Sum</span>.<span class=\"name\">scaleByMonom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L105-L106","name":"Mathlib.Tactic.Linarith.Sum.one","line":105,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.one","doc":"`1` is represented as the singleton sum of the monomial `Monom.one` with coefficient 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum.one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Sum</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\">Sum</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L102-L103","name":"Mathlib.Tactic.Linarith.Sum","line":102,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum","doc":"Linear combinations of monomials are represented by mapping monomials to coefficients. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Sum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Sum</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L99-L100","name":"Mathlib.Tactic.Linarith.instOrdMonom","line":99,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.instOrdMonom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.instOrdMonom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">instOrdMonom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L93-L97","name":"Mathlib.Tactic.Linarith.Monom.lt","line":93,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom.lt","doc":"Compare monomials by first comparing their keys and then their powers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom.lt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Monom</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> → <a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L90-L91","name":"Mathlib.Tactic.Linarith.Monom.one","line":90,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom.one","doc":"`1` is represented by the empty monomial, the product of no variables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom.one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Monom</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\">Monom</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L87-L88","name":"Mathlib.Tactic.Linarith.Monom","line":87,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom","doc":"Variables (represented by natural numbers) map to their power. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Monom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Monom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L82-L83","name":"Mathlib.Tactic.Linarith.Map","line":82,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map","doc":"A local abbreviation for `TreeMap` so we don't need to write `Ord.compare` each time. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Mathlib.Tactic.Linarith.Map\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u_1 u_2)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L71-L78","name":"instAddTreeMapOfZeroOfDecidableEq_mathlib","line":71,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#instAddTreeMapOfZeroOfDecidableEq_mathlib","doc":"We introduce a local instance allowing addition of `TreeMap`s,\nremoving any keys with value zero.\nWe don't need to prove anything about this addition, as it is only used in meta code.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#instAddTreeMapOfZeroOfDecidableEq_mathlib\"><span class=\"name\">instAddTreeMapOfZeroOfDecidableEq_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">c</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Zero\">Zero</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeMap/Basic.html#Std.TreeMap\">Std.TreeMap</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">c</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L58-L68","name":"List.findDefeq","line":58,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#List.findDefeq","doc":"`findDefeq red m e` looks for a key in `m` that is defeq to `e` (up to transparency `red`),\nand returns the value associated with this key if it exists.\nOtherwise, it fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#List.findDefeq\"><span class=\"name\">List</span>.<span class=\"name\">findDefeq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">v</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">v</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L50-L50","name":"Std.TreeMap.instBEq_mathlib","line":50,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Std.TreeMap.instBEq_mathlib","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Std.TreeMap.instBEq_mathlib\"><span class=\"name\">Std</span>.<span class=\"name\">TreeMap</span>.<span class=\"name\">instBEq_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">c</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeMap/Basic.html#Std.TreeMap\">TreeMap</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">c</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/Linarith/Parsing.lean#L37-L48","name":"Std.TreeMap.beq","line":37,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Parsing.html#Std.TreeMap.beq","doc":"Returns true if the two maps have the same size and the same keys and values\n(with keys compared using the ordering, and values compared using `BEq`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Parsing.html#Std.TreeMap.beq\"><span class=\"name\">Std</span>.<span class=\"name\">TreeMap</span>.<span class=\"name\">beq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">c</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m₁ </span><span class=\"fn\">m₂</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeMap/Basic.html#Std.TreeMap\">TreeMap</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"}]}