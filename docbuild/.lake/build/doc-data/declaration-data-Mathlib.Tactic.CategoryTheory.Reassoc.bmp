{"name":"Mathlib.Tactic.CategoryTheory.Reassoc","instances":[],"imports":["Init","Mathlib.CategoryTheory.Functor.Basic","Mathlib.Lean.Meta.Simp","Mathlib.Tactic.Simps.Basic","Mathlib.Util.AddRelatedDecl"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L122-L132","name":"CategoryTheory.«termReassoc_of%_»","line":122,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.«termReassoc_of%_»","doc":"`reassoc_of% t`, where `t` is\nan equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\nThis also works for equations between isomorphisms, provided that\n`Tactic.CategoryTheory.IsoReassoc` has been imported.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.«termReassoc_of%_»\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">«termReassoc_of%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L98-L108","name":"CategoryTheory.reassocExpr","line":98,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr","doc":"Reassociates the morphisms in `type?` using the registered handlers,\nusing `reassocExprHom` as the default.\nIf `type?` is not given, it is assumed to be the type of `pf`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassocExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L87-L94","name":"CategoryTheory.registerReassocExpr","line":87,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.registerReassocExpr","doc":"Registers a handler for `reassocExpr`. The handler takes a proof of an equation\nand returns a proof of the reassociation lemma.\nHandlers are considered in order of registration.\nThey are applied directly to the equation in the body of the forall.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.registerReassocExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">registerReassocExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L55-L76","name":"CategoryTheory.reassoc","line":55,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassoc","doc":"Adding `@[reassoc]` to a lemma named `F` of shape `∀ .., f = g`, where `f g : X ⟶ Y` are\nmorphisms in some category, will create a new lemma named `F_assoc` of shape\n`∀ .. {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h`\nbut with the conclusions simplified using the axioms for a category\n(`Category.comp_id`, `Category.id_comp`, and `Category.assoc`).\nSo, for example, if the conclusion of `F` is `a ≫ b = g` then\nthe conclusion of `F_assoc` will be `a ≫ (b ≫ h) = g ≫ h` (note that `≫` reassociates\nto the right so the brackets will not appear in the statement).\n\nThis attribute is useful for generating lemmas which the simplifier can use even on expressions\nthat are already right associated.\n\nNote that if you want both the lemma and the reassociated lemma to be\n`simp` lemmas, you should tag the lemma `@[reassoc (attr := simp)]`.\nThe variant `@[simp, reassoc]` on a lemma `F` will tag `F` with `@[simp]`,\nbut not `F_assoc` (this is sometimes useful).\n\nThis attribute also works for lemmas of shape `∀ .., f = g` where `f g : X ≅ Y` are\nisomorphisms, provided that `Tactic.CategoryTheory.IsoReassoc` has been imported.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassoc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L47-L53","name":"CategoryTheory.reassocExprHom","line":47,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExprHom","doc":"Given an equation `f = g` between morphisms `X ⟶ Y` in a category,\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExprHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassocExprHom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L41-L45","name":"CategoryTheory.categorySimp","line":41,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.categorySimp","doc":"Simplify an expression using only the axioms of a category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.categorySimp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">categorySimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/80ef7ee04d6e4d69bb5ec32dc5fc93ed19cd1fbc/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L37-L39","name":"CategoryTheory.eq_whisker'","line":37,"kind":"theorem","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.eq_whisker'","doc":"A variant of `eq_whisker` with a more convenient argument order for use in tactics. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.eq_whisker'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">eq_whisker'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">w</span> : <span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">Z</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></div></div>"}]}